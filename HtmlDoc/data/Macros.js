const macros =
  {
    names:
      [
        'defecb-advice',
        'defecb-advice-set',
        'defecb-autocontrol/sync-function',
        'defecb-multicache',
        'defecb-stealthy',
        'defecb-tree-buffer-callback',
        'defecb-tree-buffer-creator',
        'defecb-window-dedicator-to-ecb-buffer',
        'ecb-ad-with-originals',
        'ecb-create-layout-insert-line',
        'ecb-do-if-buffer-visible-in-ecb-frame',
        'ecb-do-with-fixed-ecb-buffers',
        'ecb-do-with-unfixed-ecb-buffers',
        'ecb-eshell-save-buffer-history',
        'ecb-exec-in-window',
        'ecb-exit-on-input',
        'ecb-face-default',
        'ecb-layout-define',
        'ecb-save-window-excursion',
        'ecb-throw-on-input',
        'ecb-when-point-in-edit-window-ecb-windows-visible',
        'ecb-with-dedicated-window',
        'ecb-with-ecb-advice',
        'ecb-with-original-adviced-function-set',
        'ecb-with-original-basic-functions',
        'ecb-with-original-permanent-layout-functions',
        'ecb-with-readonly-buffer',
        'ecb-working-status-timeout',
        'silentcomp-defun',
        'silentcomp-defvar',
        'silentcomp-provide',
        'tree-buffer-defpopup-command'
    ],

    info:
      [
        {
          macro : 'defecb-advice',
          filename : 'ecb/ecb-common-browser.el',
          docstring : '  "Defines an advice for ADVICED-FUNCTION with ADVICE-CLASS for ADVICE-SET.<br>ADVICED-FUNCTION must be an advicable object (e.g. a function, a subr<br>etc...). ADVICE-CLASS must be one of around, after or before. ADVICE-SET must<br>ba an advice-set previously defined by `defecb-advice-set". ADVICE-DOCSTRING<br>ist the docstring for the advice. BODY is the program-code for the advice as<br>it would be written with `defadvice".<br><br>Do not quote ADVICED-FUNCTION, ADVICE-CLASS and ADVICE-SET.<br><br>Example:<br><br>(defecb-advice delete-frame around ecb-layout-basic-adviced-functions<br>  "If FRAME is equal to the ECB frame then..."<br>  (let ((frame (or (ad-get-arg 0) (selected-frame))))<br>    (if (and ecb-minor-mode<br>             (equal frame ecb-frame))<br>        (when (ecb-confirm "Attempt to delete the ECB-frame....Proceed? ")<br>	  (ecb-deactivate-internal)<br>	  ad-do-it)<br>      ad-do-it)))"',
          prototype : '(defmacro defecb-advice (adviced-function advice-class advice-set advice-docstring &rest body)',
          parameter : 'adviced-function advice-class advice-set advice-docstring &rest body',
          lispcode : '(defmacro defecb-advice (adviced-function advice-class advice-set advice-docstring &rest body)<br>  <backtick>(progn<br>     (if (assoc (quote ,advice-set) ecb-adviced-function-sets)<br>         (add-to-list (quote ,advice-set)<br>                      (cons (quote ,adviced-function) (quote ,advice-class)))<br>       (error <apo>The advice-set %s does not exist!<apo><br>              (symbol-name (quote ,advice-set))))<br>     (if (not (member (quote ,advice-class)<br>                      <tick>(around after before)))<br>         (error <apo>The advice-class %s is not allowed - only around, after and before!<apo><br>                (symbol-name (quote ,advice-class))))<br>     (add-to-list <tick>ecb-adviced-functions (cons (quote ,adviced-function) (quote ,advice-class)))<br>     (eval-and-compile<br>       (defadvice ,adviced-function (,advice-class ecb)<br>         ,advice-docstring<br>         (ecb-advices-debug-error (quote ,adviced-function)<br>                                  (quote ,advice-class)<br>                                  <tick>calling)<br>         ,@body))))'
        },
        {
          macro : 'defecb-advice-set',
          filename : 'ecb/ecb-common-browser.el',
          docstring : '  "Defines an advice-set for ECB.<br>This defines a variable which will contain adviced functions defined by<br>`defecb-advice-set". This is a set of advices which can be enabled or disabled<br>"en block" which must be done either by `ecb-enable-advices",<br>`ecb-disable-advices" or `ecb-with-original-adviced-function-set".<br><br>Before defining a new advice-set it"s recommended to take a look at the value<br>of `ecb-adviced-function-sets" if there is already a suitable advice-set.<br><br>IMPORTANT: Each advice in ECB must be defined by `defecb-advice" and must<br>belong to an advice-set previously defined by `defecb-advice-set"!<br><br>All advice-sets of ECB will be automatically(!) disabled at load-time of the<br>ecb-library and at deactivation-time of ECB. But: Enabling of a certain<br>advice-set must be done appropriately.<br><br>If optional argument PERMANENT is t then this advice-set will NOT be disabled<br>at deactivation-time of ECB! Calling `ecb-disable-advices" for an advice set<br>defined with permanent is t will take no effect unless the optional argument<br>FORCE-PERMANENT of this function is set to not nil.<br>PERMANENT can also be a function which will be called by `ecb-disable-advices"<br>for this advice set (the function gets one argument: the symbol of the<br>advice-set) and have to return not nil if the advice-set should not be disable<br>by `ecb-disable-advices" unless the FORCE-PERMANENT of this function is set to<br>not nil.<br><br>Example:<br><br>(defecb-advice-set ecb-always-disabled-advices<br>  "These advices are always disabled.")"',
          prototype : '(defmacro defecb-advice-set (advice-set docstring &optional permanent)',
          parameter : 'advice-set docstring &optional permanent',
          lispcode : '(defmacro defecb-advice-set (advice-set docstring &optional permanent)<br>  <backtick>(eval-and-compile<br>     (add-to-list <tick>ecb-adviced-function-sets (cons (quote ,advice-set), nil))<br>     ,(if permanent<br>          <backtick>(add-to-list <tick>ecb-adviced-permanent-function-sets<br>                        (cons (quote ,advice-set) ,permanent)))<br>     (defvar ,advice-set nil ,docstring)))'
        },
        {
          macro : 'defecb-autocontrol/sync-function',
          filename : 'ecb/ecb-common-browser.el',
          docstring : '  "Define a function run either by idle-timer or before or after each command.<br>Such a function is used either for automatic self-controlling certain aspects<br>of ECB or for synchronizing a special window/buffer of ECB with contents of<br>the active buffer in the edit-area.<br><br>FCN is the name of the defined function and BUFFER-NAME-SYMBOL is<br>either nil or a variable-symbol containing the buffer-name<br>of a special ECB-window/buffer for which the defined function is<br>used for synchronizing it with the edit-area. In the latter case<br>BODY is encapsulated with the macros a)<br>`ecb-when-point-in-edit-window-ecb-windows-visible" and b)<br>`ecb-do-if-buffer-visible-in-ecb-frame" so BODY runs only if a)<br>point stays in an edit-window (ie. the currently selected window<br>is an edit-window) and the ecb-windows of current layout are<br>not hidden and b) the buffer of BUFFER-NAME-SYMBOL is displayed in a<br>window of the ECB-frame (for details see the documentation of<br>this macro).<br><br>Please note: If BUFFER-NAME-SYMBOL is nil then BODY is not<br>encapsulated with these two macros mentioned above!<br><br>The defined function has an optional argument FORCE which can be used within<br>BODY.<br><br>BUFFER-SYNC-OPTION-SYMBOL is either nil or the name of an option<br>which defines if and under which circumstances the<br>synchronization should take place. Such an option must be of the<br>same type and must offer exactly the same values as `ecb-analyse-buffer-sync".<br>If BUFFER-SYNC-OPTION-SYMBOL is not nil and a valid symbol then the generated<br>function encapsulates BODY in a when-statement whereas the condition-clause is<br>exactly true when either:<br>- force is not nil or<br>- The value of BUFFER-SYNC-OPTION-SYMBOL is t or "always or<br>- The major-mode of current buffer is not contained in the list-value of<br>  BUFFER-SYNC-OPTION-SYMBOL or<br>- The value of BUFFER-SYNC-OPTION-SYMBOL is "basic and the conditions above<br>  are true for `ecb-basic-buffer-sync".<br><br>If call-interactive-p is not nil then FCN will be defined as an interactice<br>command, i.e. it will contain the clause (interactive "P").<br><br>The defined function is automatically prepared for tracing its calls when<br>`ecb-autotrace-autocontrol/sync-functions" is either set to t or the symbol of FCN<br>is contained in the list of this variable. In this case a trace-statemant with<br>time-details is reported to the message-buffer directly before and after BODY.<br><br>Do not quote FCN, BUFFER-NAME-SYMBOL and BUFFER-SYNC-OPTION-SYMBOL!<br><br>Example:<br><br>(defecb-autocontrol/sync-function ecb-sync-a-buffer ecb-a-special-buffer-name<br>   ecb-a-special-buffer-sync nil<br>  "Synchronize the buffer of ECB-A-SPECIAL-BUFFER-NAME with..."<br>  (let ((x nil))<br>    (if force<br>        ;; do something<br>      ;; do something else<br>      )<br>    ))<br><br>This defines a non interactive function `ecb-sync-a-buffer" which<br>should be used for synchronizing the special buffer the name is<br>hold in the variable `ecb-a-special-buffer-name".<br>"',
          prototype : '(defmacro defecb-autocontrol/sync-function (fcn buffer-name-symbol                                                buffer-sync-option-symbol                                                called-interactively-p docstring                                                &rest body)',
          parameter : 'fcn buffer-name-symbol buffer-sync-option-symbol called-interactively-p docstring &rest body',
          lispcode : '(defmacro defecb-autocontrol/sync-function (fcn buffer-name-symbol<br>                                                buffer-sync-option-symbol<br>                                                called-interactively-p docstring<br>                                                &rest body)<br>  <backtick>(eval-and-compile<br>     (ecb-register-autocontrol/sync-function (quote ,fcn) (quote ,buffer-name-symbol))<br><br>     (defun ,fcn (&optional force)<br>       ,docstring<br>       ,(if called-interactively-p<br>            <tick>(interactive <apo>P<apo>))<br>       (ecb-autotrace-autocontrol/sync-fcn-error (quote ,fcn)<br>                                                 <apo>Begin: Cur-buf: %s<apo> (current-buffer))<br>       (let (,(if (and buffer-sync-option-symbol (symbolp buffer-sync-option-symbol))<br>                  <backtick>(,buffer-sync-option-symbol (if (equal<br>                                                    ,buffer-sync-option-symbol<br>                                                    <tick>basic)<br>                                                   ecb-basic-buffer-sync<br>                                                 ,buffer-sync-option-symbol))<br>                ;; we need anything to bound in the else-fork, so we just bind<br>                ;; major-mode to major-mode - we could use any variable, takes<br>                ;; no effect<br>                <backtick>(major-mode major-mode))<br>;;                 <backtick>(,(make-symbol <apo>abc123xyz456efg789<apo>) nil))<br>             )<br>         (when ,(if (and buffer-sync-option-symbol (symbolp buffer-sync-option-symbol))<br>                    <backtick>(or force<br>                         (equal <tick>always ,buffer-sync-option-symbol)<br>                         (equal t ,buffer-sync-option-symbol)<br>                         (and ,buffer-sync-option-symbol<br>                              (listp ,buffer-sync-option-symbol)<br>                              (not (member major-mode ,buffer-sync-option-symbol))))<br>                  t)<br>           ,(if (and buffer-name-symbol (symbolp buffer-name-symbol))<br>                <backtick>(ecb-when-point-in-edit-window-ecb-windows-visible<br>                  (ecb-do-if-buffer-visible-in-ecb-frame (quote ,buffer-name-symbol)<br>                    (ecb-bodytrace-autocontrol/sync-fcn-error (quote ,fcn)<br>                                                              <apo>After conditions: Cur-buf: %s<apo> (current-buffer))<br>                    ,@body<br>                    (ecb-autotrace-autocontrol/sync-fcn-error (quote ,fcn)<br>                                                              <apo>End:   Cur-buf: %s<apo> (current-buffer))<br>                    nil ;; we always return nil<br>                    ))<br>              <backtick>(progn<br>                 (ecb-bodytrace-autocontrol/sync-fcn-error (quote ,fcn)<br>                                                           <apo>After conditions: Cur-buf: %s<apo> (current-buffer))<br>                 ,@body<br>                 (ecb-autotrace-autocontrol/sync-fcn-error (quote ,fcn)'
        },
        {
          macro : 'defecb-multicache',
          filename : 'ecb/ecb-util.el',
          docstring : '  "Defines NAME as variable and makes it an ecb-multicache.<br>This means that for each cache-item of the cache NAME informations can be<br>associated to different subcaches. SUBCACHE is either a symbol or a list of<br>symbols. For each symbol in SUBCACHE a subcache is reserved in the cache NAME.<br><br>Such a cache is especially senseful if different informations should be<br>associated to one key.<br><br>SIZE is a hint as to how many elements will be put in the cache. If SIZE is<br>nil then the default is 100. If the cache exceeds SIZE it will be increased<br>automatically.<br><br>TEST must be a symbol that specifies how to compare keys. If TEST is nil then<br>the default is `equal".<br><br>After defining the cache with this macro the cache can be used immediately;<br>there is no need for special initialization. The following functions are<br>available for setting and accessing values in such a cache:<br><br>  `ecb-multicache-put-value"<br>  `ecb-multicache-apply-to-value"<br>  `ecb-multicache-get-value"<br>  `ecb-multicache-mapsubcache"<br>  `ecb-multicache-clear-value"<br>  `ecb-multicache-clear-subcache"<br>  `ecb-multicache-remove"<br>  `ecb-multicache-clear"<br>  `ecb-multicache-print-subcache"<br>  `ecb-multicache-p"<br><br>The lookup in this multi-cache is really fast because the time required is<br>essentially _independent_ of how many elements are stored in the cache."',
          prototype : '(defmacro defecb-multicache (name size test subcache docstring)',
          parameter : 'name size test subcache docstring',
          lispcode : '(defmacro defecb-multicache (name size test subcache docstring)<br>  <backtick>(progn<br>     (eval-and-compile<br>       (defvar ,name nil ,docstring))<br>     (unless (get <tick>,name <tick>ecb-multicache-p)<br>       (setq ,name nil)<br>       (put <tick>,name <tick>ecb-multicache-subcache-list<br>            (if (listp ,subcache)<br>                ,subcache<br>              (list ,subcache)))<br>       (put <tick>,name <tick>ecb-multicache-p t)<br>       (put <tick>,name <tick>ecb-multicache-size ,(or size 100))<br>       (put <tick>,name <tick>ecb-multicache-test ,(or test (quote <tick>equal)))<br>       )))<br>(put <tick>defecb-multicache <tick>lisp-indent-function 4)<br><br>;; (insert (pp (macroexpand <tick>(defecb-multicache klaus nil <tick>equal <tick>(A B C) <apo>docstring<apo>))))<br>'
        },
        {
          macro : 'defecb-stealthy',
          filename : 'ecb/ecb-common-browser.el',
          docstring : '  "Define a so called stealthy function with NAME. This function will be<br>registered by this macro in `ecb-stealthy-function-list" and<br>`ecb-stealthy-function-state-alist". During the evaluation of BODY the<br>variable `state" will be bound and initialized with the stealthy state. BODY<br>can use and modify `state". After evaluating BODY `state" will be<br>automatically saved so its available at the runtime of this stealthy function.<br>BODY will only be evaluated if `state" is not "done. BODY should be designed<br>to be interruptable by the user, so its recommended to use for this<br>`ecb-exit-on-input" ans `ecb-throw-on-input" (see example in<br>`ecb-test-throw-on-input"). If BODY completes then BODY has to set `state" to<br>the special value "done! If BODY has been interrupted then `state" can have an<br>arbitrary value which will be autom. stored and at next runtime of the<br>stealthy function NAME `state" will be initialized with this stored value. If<br>`state" is initialized with the special value "restart then this means the<br>stealthy function should start from scratch because an eventually stored state<br>is not longer valid. If the stealthy function sets `state" to "done then this<br>function will first being called after the state for this function has been<br>reset to something else than "done (mostly to "restart); such a reset of the<br>state for a stealthy function can be done by any code and must be done via<br>`ecb-stealthy-function-state-init"!"',
          prototype : '(defmacro defecb-stealthy (name docstring &rest body)',
          parameter : 'name docstring &rest body',
          lispcode : '(defmacro defecb-stealthy (name docstring &rest body)<br>  <backtick>(progn<br>     (unless (fboundp (quote ,name))<br>       (ecb-stealthy-function-list-add (quote ,name))<br>       (ecb-stealthy-function-state-alist-add (quote ,name)))<br>     (eval-and-compile<br>       (unless (fboundp (quote ,name))<br>         (defun ,name nil<br>           ,docstring<br>           (let ((state (ecb-stealthy-function-state-get (quote ,name))))<br>             (unless (equal state <tick>done)<br>               ,@body)<br>             (ecb-stealthy-function-state-set (quote ,name) state)))))))'
        },
        {
          macro : 'defecb-tree-buffer-callback',
          filename : 'ecb/ecb-common-browser.el',
          docstring : '  "Define a callback-function CALLBACK for a tree-buffer which name is hold in<br>the symbol TREE-BUFFER-NAME-SYMBOL. Do not quote CALLBACK and<br>TREE-BUFFER-NAME-SYMBOL and CALLBACK-TYPE. DOCSTRING is the<br>docstring for CALLBACK. BODY is all the program-code of CALLBACK.<br><br>CALLBACK-TYPE must be either "expand or "select, whereas the<br>former one defines a callback for handling expanding a node and<br>the latter one for clicking onto a node.<br><br>CALLBACK is defined as a function with at least five arguments:<br>NODE, ECB-BUTTON, EDIT-WINDOW-NR, SHIFT-MODE and META-MODE.<br>CALLBACK must handle clicking onto NODE in the tree-buffer for<br>which the callback is defined. ECB-BUTTON can be 1, 2 or 3 (=<br>mouse-buttons). If 3 then EDIT-WINDOW-NR contains the number of<br>the edit-window the NODE should be displayed or whatever should<br>be done with NODE. For 1 and 2 the value of EDIT-WINDOW-NR is<br>ignored. SHIFT-MODE and META-MODE are not nil if the user has<br>pressed the shift- rsp. the meta-button during his click. Note:<br>using the keyboard in the tree-buffer instead the mouse is<br>already handled by the caller of CALLBACK, so CALLBACK has no<br>need to bother with keyboard or mouse specific stuff!<br><br>If OPTIONAL-ARG-LIST is not nil then it must be a list with all<br>optional or rest arguments. You have to include the keywords<br>&optional or/and &rest! The first item of this list must be<br>either the keyword &optional or &rest! The defined CALLBACK gets<br>exactly these additional arguments after the reqired 5 arguments<br>described above. Do not quote OPTIONAL-ARG-LIST!<br><br>The defined CALLBACK automatically hides the ecb-windows after<br>selecting a node in case META-MODE is not nil and if the CALLBACK<br>is of type "select; this is a must for every tree-buffer. Do not<br>do this within BODY! But: During the evaluation of BODY the local<br>variable no-meta-hiding is bound and set to nil per default. If<br>BODY sets it to not nil then the hiding of the ecb-windows is<br>prevented even if META-MODE is not nil.<br><br>The value of the last expression of BODY is returned.<br><br>This macro automatically adds the appropriate description of the<br>5 arguments of the defined CALLBACK to DOCSTRING. So just<br>describe what the CALLBACK does!<br><br>It is strongly recommended defining a callback-function for a<br>tree-buffer of ECB with this macro and not with plain `defun",<br>because then a lot of stuff needed to be done by every<br>tree-buffer is automatically performed."',
          prototype : '(defmacro defecb-tree-buffer-callback (callback                                       tree-buffer-name-symbol                                       callback-type                                       optional-arg-list                                       docstring &rest body)',
          parameter : 'callback tree-buffer-name-symbol callback-type optional-arg-list docstring &rest body',
          lispcode : '(defmacro defecb-tree-buffer-callback (callback<br>                                       tree-buffer-name-symbol<br>                                       callback-type<br>                                       optional-arg-list<br>                                       docstring &rest body)<br>  <backtick>(eval-and-compile<br>     (ecb-tree-buffer-callbacks-add (quote ,callback-type)<br>                                    (quote ,tree-buffer-name-symbol)<br>                                    (quote ,callback))<br>     (defun ,callback ,(append <tick>(node ecb-button edit-window-nr shift-mode meta-mode)<br>                               optional-arg-list)<br>       ,(concat (if (equal callback-type <tick>select)<br>                    (concat<br>                     <apo>Handle clicking onto NODE in the current tree-buffer.\n<apo><br>                     <apo>ECB-BUTTON can be 1, 2 or 3. If 3 then EDIT-WINDOW-NR contains the number\n<apo><br>                     <apo>of the edit-window the NODE should be displayed or whatever should be done\n<apo><br>                     <apo>with NODE. For 1 and 2 the value of EDIT-WINDOW-NR is ignored.\n<apo><br>                     <apo>SHIFT-MODE and META-MODE are self-explanatory.<apo>)<br>                  (concat<br>                   <apo>Handle expanding NODE in the current tree-buffer.\n<apo><br>                   <apo>ECB-BUTTON can be 1, 2 or 3. If 3 then EDIT-WINDOW-NR contains the number\n<apo><br>                   <apo>of the edit-window the NODE should be displayed or whatever should be done\n<apo><br>                   <apo>with NODE. For 1 and 2 the value of EDIT-WINDOW-NR is ignored.\n<apo><br>                   <apo>SHIFT-MODE and META-MODE are self-explanatory.<apo>))<br>                <apo>\n\n<apo><br>                docstring)<br>       (let ((no-meta-hiding nil))<br>         (prog1<br>             (progn<br>               ,@body)<br>           ,(if (equal callback-type <tick>select)<br>                <backtick>(when (and (not no-meta-hiding) meta-mode)<br>                   (ecb-run-with-idle-timer 0.001 nil <tick>ecb-hide-ecb-windows))))))))'
        },
        {
          macro : 'defecb-tree-buffer-creator',
          filename : 'ecb/ecb-common-browser.el',
          docstring : '  "Define a creator-function CREATOR for a tree-buffer which name is hold in<br>the symbol TREE-BUFFER-NAME-SYMBOL. Do not quote CREATOR and<br>TREE-BUFFER-NAME-SYMBOL. DOCSTRING is the docstring for CREATOR. BODY is all<br>the program-code of CREATOR (must contain a call to `tree-buffer-create"). It<br>makes sense that BODY returns the created tree-buffer.<br><br>When creating a tree-buffer with this macro then this tree-buffer will be<br>automatically created (i.e. its creator-function defined with this macro will<br>be called) when activating ECB and the tree-buffer will automatically<br>registered at ECB. This means that some features of ECB will work<br>automatically out of the box with this tree-buffer.<br><br>When creating a tree-buffer for ECB then it MUST be created with this macro<br>and not with `tree-buffer-create"!"',
          prototype : '(defmacro defecb-tree-buffer-creator (creator                                      tree-buffer-name-symbol                                      docstring &rest body)',
          parameter : 'creator tree-buffer-name-symbol docstring &rest body',
          lispcode : '(defmacro defecb-tree-buffer-creator (creator<br>                                      tree-buffer-name-symbol<br>                                      docstring &rest body)<br>  <backtick>(eval-and-compile<br>     (ecb-tree-buffer-creators-register (quote ,tree-buffer-name-symbol)<br>                                        (quote ,creator))<br>     (defun ,creator ()<br>       ,docstring<br>       (unless (ecb-ecb-buffer-registry-get-symbol ,tree-buffer-name-symbol)<br>         (ecb-ecb-buffer-registry-add ,tree-buffer-name-symbol<br>                                      (quote ,tree-buffer-name-symbol)<br>                                      t)<br>         ,@body))))'
        },
        {
          macro : 'defecb-window-dedicator-to-ecb-buffer',
          filename : 'ecb/ecb-layout.el',
          docstring : '  "Dedicates an ecb-window for the buffer hold in BUFFER-NAME-SYMBOL.<br>This defines a function DEDICATOR which makes the selected window<br>dedicated to that buffer-name hold in BUFFER-NAME-SYMBOL. Do not<br>quote DEDICATOR and BUFFER-NAME-SYMBOL. TREE-BUFFER-P has to be<br>not nil if the ecb-window displays a tree-buffer created with<br>`defecb-tree-buffer-creator" (in this case BUFFER-NAME-SYMBOL<br>muts be equal to the argument TREE-BUFFER-NAME-SYMBOL of that<br>macro). DOCSTRING is the docstring for DEDICATOR. BODY is all the<br>program-code of DEDICATOR which will be run encapsulated within a<br>call to `ecb-with-dedicated-window".<br><br>Example:<br><br>(defecb-window-dedicator-to-ecb-buffer ecb-set-history-buffer<br>    ecb-history-buffer-name t<br>  "Display the History-buffer in current window and make window<br>dedicated to the history buffer."<br>  (switch-to-buffer ecb-history-buffer-name))<br><br>This dedicates a window to a buffer with name<br>`ecb-history-buffer-name" by defining a function<br>`ecb-set-history-buffer" registered as "window-dedicator" for<br>this buffer. The buffer with name `ecb-history-buffer-name" is of<br>type tree-buffer. The BODY (in this example only a call to<br>switch-to-buffer) will run within the macro<br>`ecb-with-dedicated-window"!"',
          prototype : '(defmacro defecb-window-dedicator-to-ecb-buffer  (dedicator buffer-name-symbol tree-buffer-p docstring &rest body)',
          parameter : 'dedicator buffer-name-symbol tree-buffer-p docstring &rest body',
          lispcode : '(defmacro defecb-window-dedicator-to-ecb-buffer<br>  (dedicator buffer-name-symbol tree-buffer-p docstring &rest body)<br>  <backtick>(eval-and-compile<br>     (defun ,dedicator ()<br>       ,docstring<br>       (ecb-ecb-buffer-registry-add ,buffer-name-symbol<br>                                    (quote ,buffer-name-symbol)<br>                                    ,tree-buffer-p<br>                                    (quote ,dedicator))<br>       (ecb-with-dedicated-window<br>        ,@body))))'
        },
        {
          macro : 'ecb-ad-with-originals',
          filename : 'ecb/ecb-compatibility.el',
          docstring : '  "Binds FUNCTIONS to their original definitions and execute BODY.<br>For any members of FUNCTIONS that are not currently advised the rebinding will<br>be a noop.  Any modifications done to the definitions of FUNCTIONS will be<br>undone on exit of this macro."',
          prototype : '(defmacro ecb-ad-with-originals (functions &rest body)',
          parameter : 'functions &rest body',
          lispcode : '(defmacro ecb-ad-with-originals (functions &rest body)<br>  (declare (indent 1))<br>  (let* ((index -1)<br>	 ;; Make let-variables to store current definitions:<br>	 (current-bindings<br>	  (mapcar (function<br>		   (lambda (function)<br>                    (setq index (1+ index))<br>                    (list (intern (format <apo>ad-oRiGdEf-%d<apo> index))<br>                          <backtick>(symbol-function <tick>,function))))<br>		  functions)))<br>    <backtick>(let ,current-bindings<br>      (unwind-protect<br>           (progn<br>             ,@(progn<br>                ;; Make forms to redefine functions to their<br>                ;; original definitions if they are advised:<br>                (setq index -1)<br>                (mapcar (lambda (function)<br>                          (setq index (1+ index))<br>                           <backtick>(fset <tick>,function<br>                            (or (ad-get-orig-definition <tick>,function)<br>                                ,(car (nth index current-bindings)))))<br>                        functions))<br>             ,@body)<br>        ,@(progn<br>           ;; Make forms to back-define functions to the definitions<br>           ;; they had outside this macro call:<br>           (setq index -1)<br>           (mapcar (lambda (function)<br>                     (setq index (1+ index))<br>                       <backtick>(fset <tick>,function'
        },
        {
          macro : 'ecb-create-layout-insert-line',
          filename : 'ecb/ecb-create-layout.el',
          docstring : '  "Insert LINE in current-buffer and adds a newline."',
          prototype : '(defmacro ecb-create-layout-insert-line (line)',
          parameter : 'line',
          lispcode : '(defmacro ecb-create-layout-insert-line (line)<br>  <backtick>(progn<br>     (insert ,line)<br>     (insert <apo>\n<apo>)))'
        },
        {
          macro : 'ecb-do-if-buffer-visible-in-ecb-frame',
          filename : 'ecb/ecb-util.el',
          docstring : '  "Evaluate BODY if a buffer is visible in the ECB-frame.<br><br>This means in fact if the following conditions are all true:<br>- The symbol BUFFER-NAME-SYMBOL is bound<br>- The value of BUFFER-NAME-SYMBOL is a name of a living buffer B<br>- The buffer B is visible and displayed in a window of the `ecb-frame"<br>- ECB is active<br>- The current frame is the `ecb-frame"<br>- The window of buffer B is not a window in the edit-area.<br>If one of these conditions is false then nothing will be done.<br><br>During the evaluation of BODY the following local variables are bound:<br>- visible-buffer: The buffer-object which name is the value of<br>  BUFFER-NAME-SYMBOL.<br>- visible-window: The window which displays visible-buffer"',
          prototype : '(defmacro ecb-do-if-buffer-visible-in-ecb-frame (buffer-name-symbol &rest body)',
          parameter : 'buffer-name-symbol &rest body',
          lispcode : '(defmacro ecb-do-if-buffer-visible-in-ecb-frame (buffer-name-symbol &rest body)<br>  <backtick>(let* ((visible-buffer (if (and (boundp ,buffer-name-symbol)<br>                                   (stringp (symbol-value ,buffer-name-symbol)))<br>                              (get-buffer (symbol-value ,buffer-name-symbol))))<br>          (visible-window (if (bufferp visible-buffer)<br>                              (get-buffer-window visible-buffer))))<br>     (when (and ecb-minor-mode<br>                (equal (selected-frame) ecb-frame)<br>                visible-window<br>                (window-live-p visible-window)<br>                (not (member visible-window (ecb-canonical-edit-windows-list))))<br>       ,@body)))<br>(put <tick>ecb-do-if-buffer-visible-in-ecb-frame <tick>lisp-indent-function 1)'
        },
        {
          macro : 'ecb-do-with-fixed-ecb-buffers',
          filename : 'ecb/ecb-layout.el',
          docstring : '  "Evaluate BODY with fixed size of all current-visible ecb-buffers and<br>ensure that at the end (either after finishing of BODY or after an error<br>occurs during BODY) all now current visible ecb-buffers get the value of their<br>buffer-local `window-size-fixed" from the setting in `ecb-fix-window-size"."',
          prototype : '(defmacro ecb-do-with-fixed-ecb-buffers (&rest body)',
          parameter : '&rest body',
          lispcode : '(defmacro ecb-do-with-fixed-ecb-buffers (&rest body)<br>  <backtick>(unwind-protect<br>       (progn<br>         (ecb-set-window-size-fixed t)<br>         ,@body)<br>     (ecb-set-window-size-fixed (ecb-get-window-fix-type ecb-layout-name))))<br><br>'
        },
        {
          macro : 'ecb-do-with-unfixed-ecb-buffers',
          filename : 'ecb/ecb-layout.el',
          docstring : '  "Evaluate BODY with unfixed size of all current-visible ecb-buffers and<br>ensure that at the end (either after finishing of BODY or after an error<br>occurs during BODY) all now current visible ecb-buffers get the value of their<br>buffer-local `window-size-fixed" from the setting in `ecb-fix-window-size"."',
          prototype : '(defmacro ecb-do-with-unfixed-ecb-buffers (&rest body)',
          parameter : '&rest body',
          lispcode : '(defmacro ecb-do-with-unfixed-ecb-buffers (&rest body)<br>  <backtick>(unwind-protect<br>       (progn<br>         (ecb-set-window-size-fixed nil)<br>         ,@body)<br>     (ecb-set-window-size-fixed (ecb-get-window-fix-type ecb-layout-name))))'
        },
        {
          macro : 'ecb-eshell-save-buffer-history',
          filename : 'ecb/ecb-eshell.el',
          docstring : '  "Protect the buffer-list so that the eshell buffer name is not placed early<br>in the buffer list or at all if it currently doesn"t exist."',
          prototype : '(defmacro ecb-eshell-save-buffer-history (&rest body)',
          parameter : '&rest body',
          lispcode : '(defmacro ecb-eshell-save-buffer-history (&rest body)<br>  (let ((eshell-buffer-list (make-symbol <apo>my-buffer-list<apo>)))<br>    <backtick>(let ((,eshell-buffer-list (ecb-frame-parameter (selected-frame)<br>                                                     <tick>buffer-list)))<br>       (unwind-protect<br>           (progn<br>             ,@body)<br>         (modify-frame-parameters nil (list (cons <tick>buffer-list<br>                                                  ,eshell-buffer-list)))))))'
        },
        {
          macro : 'ecb-exec-in-window',
          filename : 'ecb/ecb-util.el',
          docstring : '  "Evaluates BODY in that window which displays the buffer BUFFER-OR-NAME<br>which can be either a buffer-object or a buffer-name. If that window is not<br>visible then BODY is not evaluated and the symbol "window-not-visible is<br>returned. Otherwise the return value of BODY is returned. Runs encapsulated in<br>`save-selected-window" and `save-excursion"."',
          prototype : '(defmacro ecb-exec-in-window (buffer-or-name &rest body)',
          parameter : 'buffer-or-name &rest body',
          lispcode : '(defmacro ecb-exec-in-window (buffer-or-name &rest body)<br>  <backtick>(save-selected-window<br>     (if (not (ecb-window-select ,buffer-or-name))<br>         <tick>window-not-visible<br>       (with-current-buffer ,buffer-or-name<br>         ,@body))))'
        },
        {
          macro : 'ecb-exit-on-input',
          filename : 'ecb/ecb-util.el',
          docstring : '  "Using SYMBOL as an argument to `throw", execute FORMS.<br>If FORMS includes a call to `ecb-thow-on-input", then if a user presses any<br>key during execution, this form macro will exit with the value passed to<br>`ecb-throw-on-input". If FORMS completes, then the return value is the same as<br>`progn"."',
          prototype : '(defmacro ecb-exit-on-input (symbol &rest forms)',
          parameter : 'symbol &rest forms',
          lispcode : '(defmacro ecb-exit-on-input (symbol &rest forms)<br>  <backtick>(let ((ecb-current-input-throw-symbol ,symbol))<br>     (catch ,symbol<br>       ,@forms)))<br>(put <tick>ecb-exit-on-input <tick>lisp-indent-function 1)'
        },
        {
          macro : 'ecb-face-default',
          filename : 'ecb/ecb-face.el',
          docstring : '  "Macro for setting default values for an ECB face.<br>The parameters are set for the following display-types:<br>- ((class color) (background light)): HEIGHT, BOLD-P, ITALIC-P, INHERIT<br>                                      FG-LIGHT-COL, BG-LIGHT-COL<br>- ((class color) (background dark)): HEIGHT, BOLD-P, ITALIC-P, INHERIT<br>                                     FG-DARK-COL, BG-DARK-COL<br>- t: HEIGHT, BOLD-P, ITALIC-P, INHERIT, FG-REST, BG-REST, REVERSE-VIDEO."',
          prototype : '(defmacro ecb-face-default (&optional height bold-p italic-p                                      inherit                                      fg-light-col fg-dark-col                                      bg-light-col bg-dark-col                                      fg-rest bg-rest                                      reverse-video-p)',
          parameter : '&optional height bold-p italic-p inherit fg-light-col fg-dark-col bg-light-col bg-dark-col fg-rest bg-rest reverse-video-p',
          lispcode : '(defmacro ecb-face-default (&optional height bold-p italic-p<br>                                      inherit<br>                                      fg-light-col fg-dark-col<br>                                      bg-light-col bg-dark-col<br>                                      fg-rest bg-rest<br>                                      reverse-video-p)<br>  <backtick>(list (list <tick>((class color) (background light))<br>               (append (if ,height (list :height ,height))<br>                       (if ,bold-p (list :weight <tick>bold))<br>                       (if ,italic-p (list :slant <tick>italic))<br>                       (if ,inherit (list :inherit ,inherit))<br>                       (if ,fg-light-col (list :foreground ,fg-light-col))<br>                       (if ,bg-light-col (list :background ,bg-light-col))))<br>         (list <tick>((class color) (background dark))<br>               (append (if ,height (list :height ,height))<br>                       (if ,bold-p (list :weight <tick>bold))<br>                       (if ,italic-p (list :slant <tick>italic))<br>                       (if ,inherit (list :inherit ,inherit))<br>                       (if ,fg-dark-col (list :foreground ,fg-dark-col))<br>                       (if ,bg-dark-col (list :background ,bg-dark-col))))<br>         (list <tick>t (append (if ,height (list :height ,height))<br>                          (if ,bold-p (list :weight <tick>bold))<br>                          (if ,italic-p (list :slant <tick>italic))<br>                          (if ,inherit (list :inherit ,inherit))<br>                          (if ,fg-rest (list :foreground ,fg-rest))<br>                          (if ,bg-rest (list :foreground ,bg-rest))<br>                          (if ,reverse-video-p (list :reverse-video t))))))'
        },
        {
          macro : 'ecb-layout-define',
          filename : 'ecb/ecb-layout.el',
          docstring : '  "Creates a new ECB-layout with name NAME which must be a string. TYPE is the<br>type of the new layout and is literal, i.e. not evaluated. It can be left,<br>right, top or left-right. DOC is the docstring for the new layout-function<br>"ecb-layout-function-<name>". CREATE-CODE is all the lisp code which is<br>necessary to define the ECB-windows/buffers. This macro adds the layout with<br>NAME and TYPE to the internal variable `ecb-available-layouts".<br><br>Preconditions for CREATE-CODE:<br>1. Current frame is splitted at least in one edit-window and the column(s)<br>   (for layout types left, right and left-right) rsp. row (for a top layout)<br>   for the special ECB-windows/buffers. Depending on the value of the option<br>   `ecb-compile-window-height" there is also a compile window at the bottom of<br>   the frame which is stored in `ecb-compile-window".<br><br>2. All windows are not dedicated.<br><br>3. Neither the edit-window nor the compile-window (if there is one) are<br>   selected for types left, right and top. For type left-right the left<br>   column-window is selected.<br><br>4. All ECB-advices for the functions in `ecb-layout-basic-adviced-functions" are<br>   disabled!<br><br>Things CREATE-CODE has to do:<br>1. Splitting the ECB-windows-column(s)/row (s.a.) in all the ECB-windows the<br>   layout should contain (e.g. directories, sources, methods and history).<br>   The split must not be done with other functions than `ecb-split-hor" and<br>   `ecb-split-ver"! It is recommended not to to use a "hard" number of<br>   split-lines or -columns but using fractions between -0.9 and +0.9! Tip: It<br>   is recommended to spilt from right to left and from bottom to top or with<br>   other words: First create the right-most and bottom-most special windows!<br><br>2. Making each special ECB-window a dedicated window. This can be done with<br>   one of the following functions:<br>   + `ecb-set-directories-buffer"<br>   + `ecb-set-sources-buffer"<br>   + `ecb-set-methods-buffer"<br>   + `ecb-set-history-buffer"<br>   + `ecb-set-speedbar-buffer"<br>   + `ecb-set-analyse-buffer"<br>   + `ecb-set-symboldef-buffer"<br>   Each layout can only contain one of each tree-buffer-type!<br><br>   In addition to these functions there is a general macro:<br>   + `defecb-window-dedicator-to-ecb-buffer":<br>   This macro defines a so called "window-dedicator" which is a function<br>   registered at ECB and called by ECB to perform any arbitrary code in<br>   current window and makes the window autom. dedicated at the end. This can<br>   be used by third party packages like JDEE to create arbitrary ECB-windows<br>   besides the standard tree-windows.<br><br>   To make a special ECB-window a dedicated window for an<br>   ecb-buffer either one of the seven functions above must be used<br>   or a new "window-dedicator"-function has to be defined with<br>   `defecb-window-dedicator-to-ecb-buffer" and must be used within the<br>   layout-definition.<br><br>3. Every(!) special ECB-window must be dedicated as described in 2.<br><br>4. CREATE-CODE must work correctly regardless if there is already a<br>   compile-window (stored in `ecb-compile-window") or not<br>   (`ecb-compile-window" is nil)<br><br>Things CREATE-CODE can do or can use:<br>1. Using the values of `ecb-compile-window-height", `ecb-windows-width",<br>   `ecb-windows-height" and `ecb-compile-window-width".<br><br>Things CREATE-CODE must NOT do:<br>1. Splitting the edit-window<br>2. Creating a compile-window<br>3. Deleting the edit-window, the compile-window (if there is any) or the<br>   ECB-windows-column(s)/row (see Precondition 1.)<br>4. Referring to the values of `ecb-edit-window" or `ecb-compile-window"<br>   because these values are always nil or undefined during CREATE-CODE.<br>5. Using the function `ecb-compile-window-live-p".<br><br>Postconditions for CREATE-CODE:<br>1. The edit-window must be the selected window and must not be dedicated.<br>2. Every window besides the edit-window (and the compile-window) must be<br>   a dedicated window (e.g. a ECB-tree-window)."',
          prototype : '(defmacro ecb-layout-define (name type doc &rest create-code)',
          parameter : 'name type doc &rest create-code',
          lispcode : '(defmacro ecb-layout-define (name type doc &rest create-code)<br>  <backtick>(progn<br>     (ecb-layout-type-p (quote ,type) t)<br>     (eval-and-compile<br>       (defun ,(intern (format <apo>ecb-layout-function-%s<apo> name)) (&optional create-code-fcn)<br>         ,doc<br>         ;; Klaus Berndl <klaus.berndl@sdm.de>: creating the compile-window is<br>         ;; now done in <backtick>ecb-redraw-layout-full<tick>!<br>         ;; (when (and ecb-compile-window-height<br>         ;;            (or (equal ecb-compile-window-width <tick>frame)<br>         ;;                (equal (ecb-get-layout-type ecb-layout-name) <tick>top)))<br>         ;;   (ecb-split-ver (- ecb-compile-window-height) t t)<br>         ;;   (setq ecb-compile-window (next-window)))<br>         ,(cond ((equal type <tick>left)<br>                 <tick>(ecb-split-hor ecb-windows-width t))<br>                ((equal type <tick>right)<br>                 <tick>(ecb-split-hor (- ecb-windows-width) nil))<br>                ((equal type <tick>top)<br>                 <tick>(ecb-split-ver ecb-windows-height t))<br>                ((equal type <tick>left-right)<br>                 <tick>(progn<br>                    (ecb-split-hor (- ecb-windows-width) t)<br>                    (ecb-split-hor ecb-windows-width t t))))<br>         ;; if create-code-fcn is not nil and we have not a left-right layout<br>         ;; then we call this function instead of create-code - afterwards we<br>         ;; have to select the edit-window. If create-code-fcn is nil then the<br>         ;; leftmost-topmost ecb-window-column/bar is selected.<br>         (if (and create-code-fcn<br>                  (not (equal (ecb-get-layout-type ecb-layout-name) <tick>left-right)))'
        },
        {
          macro : 'ecb-save-window-excursion',
          filename : 'ecb/ecb-layout.el',
          docstring : '  "Same as `save-window-excursion" but it takes care of the ECB-needs."',
          prototype : '(defmacro ecb-save-window-excursion (&rest body)',
          parameter : '&rest body',
          lispcode : '(defmacro ecb-save-window-excursion (&rest body)<br>  (let ((current-window-config (make-symbol <apo>curr-win-conf<apo>)))<br>    <backtick>(let ((,current-window-config (ecb-current-window-configuration)))<br>       (unwind-protect<br>           (progn<br>             ,@body)<br>         (ecb-set-window-configuration ,current-window-config)))))<br><br>;; test of the advices of set-window-configuration and<br>;; current-window-configuration.<br><br>;; Show a compile-window and split the edit-area and then run this code. At'
        },
        {
          macro : 'ecb-throw-on-input',
          filename : 'ecb/ecb-util.el',
          docstring : '  "Exit with `throw" when in `ecb-exit-on-input" on user input.<br>FROM is an indication of where this function is called. Optional arg VALUE is<br>what should be thrown out and both are are combined in a cons-cell and passed<br>to `throw". It is recommended to add as FROM the name of the function calling<br>this one or a descriptive symbol which indicates part of a code has been<br>interrupted..<br><br>Example: (ecb-throw-on-input "test-inner-loop "test") would throw a<br>cons-cell ("test-inner-loop . "test")"',
          prototype : '(defmacro ecb-throw-on-input (from &optional value)',
          parameter : 'from &optional value',
          lispcode : '(defmacro ecb-throw-on-input (from &optional value)<br>  <backtick>(when (and ecb-current-input-throw-symbol<br>              (or (input-pending-p) (accept-process-output)))<br>     (throw ecb-current-input-throw-symbol (cons ,from ,value))))<br>'
        },
        {
          macro : 'ecb-when-point-in-edit-window-ecb-windows-visible',
          filename : 'ecb/ecb-layout.el',
          docstring : '  "Evaluate BODY if an edit-window is selected and ecb-windows are visible."',
          prototype : '(defmacro ecb-when-point-in-edit-window-ecb-windows-visible (&rest body)',
          parameter : '&rest body',
          lispcode : '(defmacro ecb-when-point-in-edit-window-ecb-windows-visible (&rest body)<br>  <backtick>(when (and ecb-minor-mode<br>              (not (ecb-windows-all-hidden))<br>              (ecb-point-in-edit-window-number))<br>     ,@body))'
        },
        {
          macro : 'ecb-with-dedicated-window',
          filename : 'ecb/ecb-layout.el',
          docstring : '  "Make current selected window not dedicated, evaluate BODY in current<br>window and make this window dedicated at the end. Even if an error occurs<br>during evaluating BODY the current window is always dedicated at the end!"',
          prototype : '(defmacro ecb-with-dedicated-window (&rest body)',
          parameter : '&rest body',
          lispcode : '(defmacro ecb-with-dedicated-window (&rest body)<br>  <backtick>(unwind-protect<br>       (progn<br>         (set-window-dedicated-p (selected-window) nil)<br>         ,@body)<br>     (set-window-dedicated-p (selected-window) t)))'
        },
        {
          macro : 'ecb-with-ecb-advice',
          filename : 'ecb/ecb-common-browser.el',
          docstring : '  "Evaluates BODY with the adviced version of FUNCTION-SYMBOL. The advice must<br>be defined by `defecb-advice" with class ADVICE-CLASS for the advice-set<br>`ecb-always-disabled-advices". Otherwise an error occurs. The advice is only<br>active during BODY.<br><br>BODY is protected by `unwind-protect" so in each case the advice<br>will be disabled after finishing this macro unless it is nested<br>within a call to this macro for the *same* FUNCTION-SYMBOL and<br>ADVICE-CLASS-combination! This means that the usage of this macro<br>is save for arbitrary nested calls, so full BODY is guaranted<br>being evaluated with enabled ADVICE-CLASS advice for<br>FUNCTION-SYMBOL.<br><br>Returns the value of BODY.<br><br>Example where this macro is used for `walk-windows" within another advice:<br><br>(ecb-with-ecb-advice "walk-windows "around<br>   ad-do-it)"',
          prototype : '(defmacro ecb-with-ecb-advice (function-symbol advice-class &rest body)',
          parameter : 'function-symbol advice-class &rest body',
          lispcode : '(defmacro ecb-with-ecb-advice (function-symbol advice-class &rest body)<br>  (let ((outmost-caller-p (make-symbol <apo>outmost-caller-p<apo>)))<br>    ;; we have to check if we are the outmost-caller of this macro for this<br>    ;; adviced function AND the advice-class! different advice-classes for the<br>    ;; same function have to be treated differently!!<br>    <backtick>(let ((,outmost-caller-p (unless (member ,advice-class (get ,function-symbol <tick>ecb-with-ecb-advice))<br>                                (put ,function-symbol <tick>ecb-with-ecb-advice<br>                                     (append (list ,advice-class) (get ,function-symbol <tick>ecb-with-ecb-advice)))<br>                                ,advice-class)))<br>       (if (not (member (cons ,function-symbol ,advice-class)<br>                      ecb-always-disabled-advices))<br>         (error <apo>Advice for %s with class %s not registered in ecb-always-disabled-advices!<apo><br>                (symbol-name ,function-symbol)<br>                (symbol-name ,advice-class)))<br>       (if ecb-advices-debug-error<br>           (message <apo>ECB %s: debug with always disabled ecb-advice: %s %s - ENTRY<apo><br>                    ecb-version ,advice-class ,function-symbol))<br>       (unwind-protect<br>         (progn<br>           (when ,outmost-caller-p<br>             (ecb-enable-ecb-advice ,function-symbol ,advice-class 1))<br>           ,@body)<br>         (when ,outmost-caller-p<br>           ;; Only if we are the outmost caller we are allowed to disable the<br>           ;; enabled advice<br>           (put ,function-symbol <tick>ecb-with-ecb-advice'
        },
        {
          macro : 'ecb-with-original-adviced-function-set',
          filename : 'ecb/ecb-common-browser.el',
          docstring : '  "Evaluates BODY with all adviced functions of ADVICED-FUNCTION-SET-VAR<br>being disabled (means with their original definition). Restores always (even<br>if an error occurs during evaluating BODY) the previous state of the adviced<br>functions, means it depends if the call to this macro is the outermost call:<br>Only if it is the outermost-call the advices of the used advice-set will be<br>disabled after finishing. So full BODY is guaranted being evaluated with<br>disabled advices of ADVICED-FUNCTION-SET-VAR.<br><br>ADVICED-FUNCTION-SET-VAR must be defined by `defecb-advice-set" and all<br>advices of this set must be defined by `defecb-advice". Otherwise an error<br>occurs.<br><br>Example:<br><br>(ecb-with-original-adviced-function-set "ecb-layout-basic-adviced-functions<br>   (do-something..))"',
          prototype : '(defmacro ecb-with-original-adviced-function-set (adviced-function-set-var &rest body)',
          parameter : 'adviced-function-set-var &rest body',
          lispcode : '(defmacro ecb-with-original-adviced-function-set (adviced-function-set-var &rest body)<br>  (let ((outmost-caller-p (make-symbol <apo>outmost-caller-p<apo>)))<br>    <backtick>(let ((,outmost-caller-p<br>            (unless (equal (cdr (assq ,adviced-function-set-var ecb-adviced-function-sets))<br>                           <tick>outmost-caller)<br>              ;; if we are the outmost caller of this macro we store this<br>              ;; for<br>              ;; a) following callers<br>              ;; b) ourself, so we can later reset is<br>              (setcdr (assq ,adviced-function-set-var ecb-adviced-function-sets) <tick>outmost-caller))<br>            ))<br>       (if ecb-advices-debug-error<br>           (message <apo>ECB %s: debug with original advice-set: %s - ENTRY<apo><br>                    ecb-version ,adviced-function-set-var))<br>       (unwind-protect<br>           (progn<br>             (when ,outmost-caller-p<br>               ;; we must force disabling permanent advice-sets too<br>               (ecb-disable-advices ,adviced-function-set-var t))<br>             ,@body)<br>         (when ,outmost-caller-p<br>           ;; Only if we are the outmost caller we are allowed to re-enable the'
        },
        {
          macro : 'ecb-with-original-basic-functions',
          filename : 'ecb/ecb-layout.el',
          docstring : '  "Evaluates BODY with all adviced basic-functions of ECB deactivated (means<br>with their original definition). Restores always the previous state of the ECB<br>adviced basic-functions, means after evaluating BODY it activates the advices<br>of exactly the functions in `ecb-layout-basic-adviced-functions"!"',
          prototype : '(defmacro ecb-with-original-basic-functions (&rest body)',
          parameter : '&rest body',
          lispcode : '(defmacro ecb-with-original-basic-functions (&rest body)<br>  <backtick>(ecb-with-original-adviced-function-set <tick>ecb-layout-basic-adviced-functions<br>     ,@body))'
        },
        {
          macro : 'ecb-with-original-permanent-layout-functions',
          filename : 'ecb/ecb-layout.el',
          docstring : '  "Evaluates BODY with all adviced permanent-functions of ECB deactivated<br>(means with their original definition). Restores always the previous state of<br>the ECB adviced permanent-functions, means after evaluating BODY it activates<br>the advices of exactly the functions in<br> `ecb-permanent-adviced-layout-functions"!"',
          prototype : '(defmacro ecb-with-original-permanent-layout-functions (&rest body)',
          parameter : '&rest body',
          lispcode : '(defmacro ecb-with-original-permanent-layout-functions (&rest body)<br>  <backtick>(ecb-with-original-adviced-function-set <tick>ecb-permanent-adviced-layout-functions<br>                                           ,@body))'
        },
        {
          macro : 'ecb-with-readonly-buffer',
          filename : 'ecb/ecb-util.el',
          docstring : '  "Make buffer BUFFER current but do not display it. Evaluate BODY in buffer<br>BUFFER (not read-only an evaluation-time of BODY) and make afterwards BUFFER<br>read-only. Note: All this is done with `save-excursion" so after BODY that<br>buffer is current which was it before calling this macro."',
          prototype : '(defmacro ecb-with-readonly-buffer (buffer &rest body)',
          parameter : 'buffer &rest body',
          lispcode : '(defmacro ecb-with-readonly-buffer (buffer &rest body)<br>  <backtick>(if (buffer-live-p ,buffer)<br>       (with-current-buffer ,buffer<br>         (unwind-protect<br>             (progn<br>               (setq buffer-read-only nil)<br>               ,@body)<br>           (setq buffer-read-only t)))<br>     (ecb-error <apo>Try to set a not existing buffer.<apo>)))'
        },
        {
          macro : 'ecb-working-status-timeout',
          filename : 'ecb/ecb-util.el',
          docstring : '  "Contain a block of code during which working status is shown.<br>The code may call `sit-for" or `accept-process-output", so a timer<br>is needed to update the message.<br>TIMEOUT is the length of time to wait between message updates.<br>MESSAGE is the message string to use and DONESTR is the completed text<br>to use when the functions `ecb-working-status" is called from FORMS."',
          prototype : '(defmacro ecb-working-status-timeout (timeout message donestr &rest forms)',
          parameter : 'timeout message donestr &rest forms',
          lispcode : '(defmacro ecb-working-status-timeout (timeout message donestr &rest forms)<br>  (let ((current-message (make-symbol <apo>ecb-working-current-message<apo>)))<br>    <backtick>(let* ((,current-message (current-message))<br>            (ecb-working-message ,message)<br>            (ecb-working-donestring ,donestr)<br>            (ecb-working-ref1 0)<br>            (time ,timeout)<br>            (ecb-working-timer<br>             (ecb-run-with-timer time time <tick>ecb-working-dynamic-status)))<br>       (unwind-protect<br>           (progn ,@forms)<br>         (ecb-cancel-timer ecb-working-timer)<br>         (ecb-working-dynamic-status t)<br>         (message ,current-message)))))<br>'
        },
        {
          macro : 'silentcomp-defun',
          filename : 'ecb/silentcomp.el',
          docstring : '  "Bind the symbol as a function during compilation of the file,<br>to silence the byte compiler.  Don"t use within `eval-when-compile".<br><br>If the symbol already is bound as a function, it will keep that<br>definition.  That means that this macro will not shut up warnings<br>about incorrect number of arguments.  It"s dangerous to try to replace<br>existing functions since the byte compiler might need the definition<br>at compile time, e.g. for macros and inline functions."',
          prototype : '(defmacro silentcomp-defun (fun)',
          parameter : 'fun',
          lispcode : '(defmacro silentcomp-defun (fun)<br>  <backtick>(eval-when-compile<br>     (if (not (assq <tick>,fun silentcomp-original-functions))<br>	 (setq silentcomp-original-functions<br>	       (cons (list <tick>,fun<br>			   nil<br>			   (if (fboundp <tick>,fun)<br>			       (symbol-function <tick>,fun)<br>			     <tick>unbound))<br>		     silentcomp-original-functions)))<br>     (if (and (silentcomp-is-compiling)<br>	      (not load-in-progress)<br>	      (not (fboundp <tick>,fun)))<br>	 (fset <tick>,fun (intern (concat <apo>silentcomp-ignore-fun:<apo><br>				     (symbol-name <tick>,fun)))))))'
        },
        {
          macro : 'silentcomp-defvar',
          filename : 'ecb/silentcomp.el',
          docstring : '  "Binds the symbol as a variable during compilation of the file,<br>to silence the byte compiler.  Don"t use within `eval-when-compile"."',
          prototype : '(defmacro silentcomp-defvar (var)',
          parameter : 'var',
          lispcode : '(defmacro silentcomp-defvar (var)<br>  <backtick>(eval-when-compile<br>     (if (boundp <tick>,var)<br>	 nil<br>       (if (not (memq <tick>,var silentcomp-unbound-variables))<br>	   (setq silentcomp-unbound-variables<br>		 (cons <tick>,var silentcomp-unbound-variables)))<br>       (if (and (silentcomp-is-compiling)<br>		(not load-in-progress))<br>	   (progn<br>	     (defvar ,var)<br>	     (set <tick>,var (intern (concat <apo>silentcomp-ignore-var:<apo><br>					(symbol-name <tick>,var)))))))))'
        },
        {
          macro : 'silentcomp-provide',
          filename : 'ecb/silentcomp.el',
          docstring : '  "A replacement for the `provide" form that restores the environment<br>after the compilation.  Don"t use within `eval-when-compile"."',
          prototype : '(defmacro silentcomp-provide (feature)',
          parameter : 'feature',
          lispcode : '(defmacro silentcomp-provide (feature)<br>  <backtick>(progn<br>     (eval-when-compile (silentcomp-restore-environment))<br>     (provide ,feature)))'
        },
        {
          macro : 'tree-buffer-defpopup-command',
          filename : 'ecb/tree-buffer.el',
          docstring : '  "Define a new popup-command for a tree-buffer.<br>NAME is the name of the popup-command to create. It will get one optional<br>argument NODE (s.b.) and a list of zero or more extra arguments called<br>REST-ARG-LIST, so the argument-signature of the generated command is<br>(&optional node &rest rest-arg-list). DOCSTRING is a documentation string to<br>describe the function. BODY is the code evaluated when this command is called<br>from a popup-menu of a tree-buffer.<br><br>BODY can refer to NODE which is bound to the node for which this popup-command<br>is called (i.h. that node with the point at call-time of this command) and to<br>REST-ARG-LIST which is a list of zero or more extra arguments. If the<br>generated command is called by ECB via the popup-mechanism (or the<br>tmm-mechanism) then REST-ARG-LIST is always nil. This argument list is to have<br>the freedom to program such a command more generally so it can not only be<br>called via popup but also called from some arbitrary elisp-code which can then<br>call this command with more arguments than only a NODE - if necessary.<br><br>With the function `tree-node->data" the related data of NODE is accessible<br>and returns for example in case of the directories buffer the directory for<br>which the popup-menu has been opened. The BODY can do any arbitrary things<br>with this node-data. In general all accessors (tree-node->*) for a node<br>can be used.<br><br>Example for the usage of this macro:<br><br>(tree-buffer-defpopup-command ecb-my-special-dir-popup-function<br>   "Prints the name of the directory of the node under point."<br>  (let ((node-data=dir (tree-node->data node))<br>          (first-arg-of-rest-args (car rest-arg-list)))<br>    (message "Dir under node: %s" node-data=dir)))"',
          prototype : '(defmacro tree-buffer-defpopup-command (name docstring &rest body)',
          parameter : 'name docstring &rest body',
          lispcode : '(defmacro tree-buffer-defpopup-command (name docstring &rest body)<br>  <backtick>(eval-and-compile<br>     (defun ,name (&optional node &rest rest-arg-list)<br>       ,(concat docstring<br>                <apo>\n\n<apo><br>                <apo>This is a generated command intended to be called via the popup-menu of ECB.\n<apo><br>                <apo>The arguments NODE and REST-ARG-LIST can not be inserted in an interactive\n<apo><br>                <apo>way by the end-user but are passed from ECB to this command.\n<apo><br>                <apo>NODE is that node-object for which this command is called. If NODE is nil\n<apo><br>                <apo>then the current node at point in the currently selected tree-buffer is used.\n<apo><br>                <apo>REST-ARG-LIST is a list of zero or more extra arguments passed to this command.<apo>)<br>       (interactive)<br>       (let ((node (if (and (called-interactively-p <tick>interactive) (null node))<br>                       (tree-buffer-get-node-at-point)<br>                     node)))<br>         (when node<br>           ,@body)))))'
        }
    ]
  }